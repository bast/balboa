[![Build status](https://github.com/bast/balboa/workflows/Test/badge.svg)](https://github.com/bast/balboa/actions)
[![License](https://img.shields.io/badge/license-%20MPL--v2.0-blue.svg)](LICENSE)


# balboa

Balboa computes Gaussian basis functions and their derivatives.

```
"You know all there is to know about fighting, so there's no sense us going down
that same old road again. To beat this guy, you need speed - you don't have it.
And your knees can't take the pounding, so hard running is out. And you got
arthritis in your neck, and you've got calcium deposits on most of your joints,
so sparring is out. So, what we'll be calling on is good ol' fashion blunt
force trauma. Horsepower. Heavy-duty, cast-iron, piledriving punches that will
have to hurt so much they'll rattle his ancestors. Every time you hit him with
a shot, it's gotta feel like he tried kissing the express train. Yeah! Let's
start building some hurtin' bombs!" [Rocky Balboa]
```


### Status

Experimental code.
In the process of rewriting to [Rust](https://www.rust-lang.org).


### Requirements and dependencies

You need the following to install the code:

- C++ compiler
- [CMake](https://cmake.org)
- [Python](https://www.python.org)

For testing you need:

- [CFFI](https://cffi.readthedocs.io)
- [Pytest](http://doc.pytest.org)
- [Numpy](http://www.numpy.org)


### Installation and testing

```
virtualenv venv
source venv/bin/activate
pip install -r requirements.txt
cmake -H. -Bbuild
cd build
cmake --build .
ctest
```


### Ordering of AOs

We use he following naming:

```
geo_000: undifferentiated
geo_100: 1st-order derivative wrt x
geo_010: 1st-order derivative wrt y
geo_001: 1st-order derivative wrt z
geo_200: 2nd-order derivative wrt x
geo_110: mixed derivative wrt x and y
...

```

For N basis functions and P points the ordering is given by:

```
[ geo_000                            ][ geo_100 ][ geo_010 ][ geo_001 ][ geo_200 ][ geo_110 ] ...
[ ao_1    ][ ao_2    ] ... [ ao_N    ]
[ 1 ... P ][ 1 ... P ] ... [ 1 ... P ]
```


### Cartesian to spherical transformation

The basis functions are computed as Cartesian Gaussians
and then transformed to spherical Gaussians.
Expressions for the transformation of Cartesian
to pure spherical harmonic Gaussians can be found for instance in
[IJQC 54, 83 (1995)](http://dx.doi.org/10.1002/qua.560540202).

The transformation matrices are automatically generated by `cs_trans.py`.
